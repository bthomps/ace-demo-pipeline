package com.ibm.ot4i.ace.pipeline.demo.tea;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import com.ibm.integration.test.v1.NodeSpy;
import com.ibm.integration.test.v1.SpyObjectReference;
import com.ibm.integration.test.v1.TestMessageAssembly;
import com.ibm.integration.test.v1.TestSetup;
import com.ibm.integration.test.v1.exception.TestException;

import static com.ibm.integration.test.v1.Matchers.*;
import static net.javacrumbs.jsonunit.JsonMatchers.jsonEquals;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.assertTrue;

public class TeaRESTApplication_GetFromDB_Tests {

        /*
         * TeaRESTApplication_getIndex_subflow_0001_Test
         * Test generated by IBM App Connect Enterprise Toolkit 12.0.1.0 on 10-Jun-2021 12:48:56
         */

        @AfterEach
        public void cleanupTest() throws TestException {
                // Ensure any mocks created by a test are cleared after the test runs 
                TestSetup.restoreAllMocks();
        }

        @Test
        public void TeaRESTApplication_GetFromDB_GetDBrecord_Test() throws TestException {

            // Define the SpyObjectReference
            SpyObjectReference nodeReference = new SpyObjectReference().application("TeaRESTApplication")
                            .messageFlow("gen.TeaRESTApplication").subflowNode("getIndex (Implementation)").subflowNode("GetFromDB").node("Get DB record");

            // Initialise a NodeSpy
            NodeSpy nodeSpy = new NodeSpy(nodeReference);

            // Declare a new TestMessageAssembly object for the message being sent into the node
            TestMessageAssembly inputMessageAssembly = new TestMessageAssembly();

            // Variables used for setting parameters in Local Environment
            String id = "0";

            // Add Local Environment to Message Assembly for HTTP
            inputMessageAssembly.localEnvironmentPath("HTTP.Input.Path.Segment[0]").setValue("tea");
            inputMessageAssembly.localEnvironmentPath("HTTP.Input.Path.Segment[1]").setValue("index");
            inputMessageAssembly.localEnvironmentPath("HTTP.Input.Path.Segment[2]").setValue(id);

            // Add Local Environment to Message Assembly for REST
            inputMessageAssembly.localEnvironmentPath("REST.Input.Method").setValue("GET");
            inputMessageAssembly.localEnvironmentPath("REST.Input.Operation").setValue("getIndex");
            inputMessageAssembly.localEnvironmentPath("REST.Input.Path").setValue("/tea/index/" + id);
            inputMessageAssembly.localEnvironmentPath("REST.Input.URI").setValue("http://localhost/tea/index/" + id);
            inputMessageAssembly.localEnvironmentPath("REST.Input.Parameters.id").setValue(id);
            
            // Call the message flow node with the Message Assembly
            nodeSpy.evaluate(inputMessageAssembly, true, "in");

            // Assert the terminal propagate count for the message
            assertThat(nodeSpy, terminalPropagateCountIs("out", 1));

            /* Compare Output Message 1 at output terminal out */
            TestMessageAssembly actualMessageAssembly = nodeSpy.propagatedMessageAssembly("out", 1);

            // We don't really care about the value here: if we get this far, and the JSON data
            // exists, then we've successfully connected to the database.
            assertEquals("0", actualMessageAssembly.messagePath("JSON.Data.id").getValueAsString());
    }
}